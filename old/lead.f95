module lead

contains

subroutine leadfun(M,X,n)
! *** Процедура строит матрицу для решения методом Гаусса, но на каждом шаге ставит
! *** наибольший по модулю элемент ведущим, чтобы избегать деления на близкий к нулю элемент
implicit none
character(6) :: choice='lead'
real(8), dimension(1:n+1,n) :: M
real(8), dimension(1:n) :: X
integer :: i, j, k, n
real(8), dimension(n+1) :: Help ! Вспомогательный массив. Используется для временного сохранения в него
                               ! массива или элемента при нужде в перестановке по принципу: a<->b: c=b, b=a, a=c
integer, dimension(2,n) :: Trans ! Этот массив содержит в каждой строке соответственно номера столбцов и
                                 ! строк, которые поменялись ради выбора большого по модулю ведущего элемента
! ------------------------------------------------
do k=1,n-1 ! Тот же цикл, что и в методе Гаусса, но с перестановкой строк и столбцов
    if ( abs( maxval(M(k:n,k:n)) ) > abs( minval(M(k:n,k:n)) ) ) then ! Происходит выбор наибольшего по модулю
	Trans(1:2,k)=(k-1)+maxloc(M(k:n,k:n))                         ! элемента, и его "координаты" записываются...
    else
	Trans(1:2,k)=(k-1)+minloc(M(k:n,k:n))                         ! ... в массив Trans в k-тую строку
    endif
!-------------------------------------------------
    Help(1:n+1)=M(1:n+1,Trans(2,k)) ! Все, что происходит в этом блоке, - это
    M(1:n+1,Trans(2,k))=M(1:n+1,k)  ! перестановка двух строк для получения большого
    M(1:n+1,k)=Help(1:n+1)          ! ведущего элемента в k-той (текущей) строке

    Help(1:n)=M(Trans(1,k),1:n)     ! ----"---- аналогично, меняются столбцы
    M(Trans(1,k),1:n)=M(k,1:n)
    M(k,1:n)=Help(1:n)
!-------------------------------------------------
    forall (j=k:n+1) M(j,k)=M(j,k)/M(k,k) ! Оба "forall" строят матрицу с переставленными элементами "по Гауссу"
    forall (i=k+1:n, j=k:n+1) M(j,i)=M(j,i)-M(k,i)*M(j,k)
enddo
M(n:n+1,n)=M(n:n+1,n)/M(n,n) ! (n,n)-ый элемент не нуждался в перестановке и по известным причинам не попал в цикл
!-------------------------------------------------
call solution(choice,M,X,n)
!-------------------------------------------------
! После выдачи процедурой solution массива из иксов, нужно его привести в порядок, ведь мы делали перестановки
do k=n-1,1,-1
    Help(k)=X(Trans(1,k))
    X(Trans(1,k))=X(k)
    X(k)=Help(k)
enddo

end subroutine leadfun

subroutine solution(choice,M,X,n)
! *** Процедура высчитывает массив решений, используя уже преобразованную расширенную матрицу
implicit none
integer :: i, n
real(8), dimension(1:n+1,n) :: M
real(8), dimension(1:n) :: X
character(6) :: choice ! Процедура, вызывающая solution, даст о себе знать, благодаря переменной "choice"
!-------------------------------------------------
if (choice /= 'jordan') then ! Только для метода Жордана счет иксов ведется по-другому
    do i=n,1,-1
	X(i)=M(n+1,i)-dot_product(M(i+1:n,i),X(i+1:n))
    enddo
else
    do i=1,n
	X(i)=M(n+1,i)
    enddo
endif

end subroutine solution

end module lead